<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    *{
      padding: 0;
      margin: 0;
    }
    .box{
      width: 375px;
      height: 667px;
      background: red;
    }
  </style>
</head>

<body>
  <div class="box">
    
  </div>

  <script type='text/aaa'>
  //   输入：
  // ["语文	数学	英语	政治", "132	134	110	87", "130	111	109	97", ...]
  // ["数学	英语	化学	物理", "   134   	  110	 87	  98  ", "130	111	109	97", ...]
  // 输出：
  // "语文 数学  英语  政治 化学 物理", "132	134	110	87	0	0", "0	134	110	0	87	98", ...]
  let li = ["语文	数学	英语	政治", "132	134	110	87", "130	111	109	97"]
  let wen = ["数学	英语	化学	物理", "134	110	87	98", "130	111	109	97"]
  add(li, wen)
  function add(arr1, arr2) {
    if (!arr1 || !arr1.length || !arr2 || !arr2.length) return false
    let result = []
    let temArr1 = dealArr(arr1)
    let temArr2 = dealArr(arr2)
    let tem1 = []
    let num

    temArr1.forEach
    console.log(temArr1, temArr2)
  }
  function dealArr(arr) {
    let result = []
    let length = arr[0].split('\t').length
    arr.forEach(item => {
      let tem = item.split('\t')
      tem.forEach((item2, index) => {
        if (!result[index]) result[index] = []
        result[index].push(item2)
      })
    });
    return result
  }
  // console.log(dealArr(li))
  </script>
  <!-- 执行顺序 -->
  <script>
    // console.log('script start')

    // async function async1() {
    //   await async2()
    //   console.log('async1 end')
    // }
    // async function async2() {
    //   console.log('async2 end')
    // }
    // async1()

    // setTimeout(function () {
    //   console.log('setTimeout')
    // }, 0)

    // new Promise(resolve => {
    //   console.log('Promise')
    //   resolve()
    // })
    //   .then(function () {
    //     console.log('promise1')
    //   })
    //   .then(function () {
    //     console.log('promise2')
    //   })
    // console.log('script end')


      // promise执行顺序，两次resolve会怎样：第二次resolve不执行
    // let promise1 = new Promise((resolve, reject)=>{
    //   console.log('aaa1')
    //   let p1 = new Promise((resolve, reject)=>{
    //     console.log('aaa2')
    //     resolve('aaa4')
    //     setTimeout(() => {
    //       console.log('aaa5')
    //       resolve('aaa6')
    //     }, 0);
    //   })
    //   p1.then(arg => {
    //     console.log(arg)
    //   })
    //   resolve('aaa3')
    // })
    // promise1.then(arg => {
    //   console.log(arg)
    // })
    // console.log('aaa7')

    // 闭包相关
    // let x = 5
    // function fn(x){
    //   return function(y){
    //     return y + (++x)
    //   }
    // }
    // let f = fn(6)
    // console.log(f(7))
    // console.log(x) 

    // console.log(1)
    // async function async1(){
    //   console.log(2)
    //   await console.log(3)
    //   console.log(4)
    // }
    // setTimeout(() => {
    //   console.log(5)
    // }, 0);
    // async1()
    // new Promise((res)=>{
    //   console.log(6)
    //   res()
    // }).then(()=>{
    //   console.log(7)
    // })
    // console.log(8)
    // 1,2,3,6,8,4,7,5

    // this指向与箭头函数
    // let name = 'window'
    // let obj = {
    //   name:'obj',
    //   normal(){
    //     return ()=>{
    //       console.log(this.name)
    //     }
    //   },
    //   arrow: ()=>{
    //     return function(){
    //       console.log(this.name)
    //     }
    //   }
    // }
    // let obj1 = {name: 'obj1'}
    // obj.normal.call(obj1)() // obj1
    // obj.arrow.call(obj1)()
    // let a = (value) => value
    // console.log(a.call({})(5))

    // 函数参数会在内部重新赋值，如果是原始值：字符串，数组，bool，在函数内部改变参数值，并不会影响外面的值
    // 如果是对象，传递引用，重新赋值也是同一个对象，改变对象的属性会影响外面的值
    // 但是如果传递的是对象，又将参数重新赋值一个对象，则不会影响外面的对象
    // let object = {a: 0}
    // function fun(obj){
    //   obj.a = 1
    //   obj = {a: 2}
    //   obj.b = 2
    // }
    // fun(object)
    // console.log(object) // {a: 1}

    // let a = 4
    // function fun2(obj){
    //   obj = 6
    // }
    // fun2(a)
    // console.log(a)

    function bilibili(){/*
        这是一个
        多行注释
        23333
        44444
        555555
    */}
    function multiline(fn) {
      let arr = fn.toString().split('\n')
      return arr.slice(1, arr.length -1).join('\n')
    }
    // console.log(`%c${multiline(bilibili)}`, 'color:green;') 
    class mum{
      constructor(weight){
        this.weight = weight
      }
      run(){
        console.log('i can run')
      }
    }

    class people extends mum{
      constructor(name, color, weight){
        super(weight)
        this.name = name
        this.color = color
      }
    }
    let zhangsan = new people('zhangsan', 'red', 34)
    console.log(zhangsan, zhangsan.weight)
    
  </script>
</body>

</html>